#!/usr/bin/env python
import pygame
import serial
import os, sys, time, collections
import numpy as np
import warnings

try:
    OrderedDict = collections.OrderedDict
except AttributeError:
    # python 2.6 or earlier
    import ordereddict
    OrderedDict = ordereddict.OrderedDict

from time_model import get_time_model, TimeFitError

def uint32(b0,b1,b2,b3):
    return (b3 << 24) + (b2 << 16) + (b1 << 8) + b0

def uint16(b0,b1):
    return (b1 << 8) + b0

if sys.platform.startswith('win'):
    time_func = time.clock
else:
    time_func = time.time

QUERY_DT = 1.0 # n seconds between clock info requests
DRAW_DT = 1.0/60.0 # 60 fps
SWITCH_DT = 0.5

class MyApp:
    def __init__(self):
        port = os.environ.get('LAG_TEST_PORT', None)
        if port is not None:
            ports = [port]
        else:
            if sys.platform.startswith('linux'):
                ports = ['/dev/ttyUSB0',
                         '/dev/ttyACM0',
                         ]
            else:
                raise RuntimeError('Do not know default serial ports on your '
                                   'platform. Set environment variable '
                                   'LAG_TEST_PORT.')
        for port in ports:
            try:
                self.ser = serial.Serial(port=port,
                                         timeout=0.01,
                                         baudrate=115200,
                                         )
            except serial.serialutil.SerialException:
                continue
            else:
                break
        self.ser.open()
        self.last_time = time_func() + 0.5 # give half a second to flush buffers
        self._qi = 0
        self._queries = OrderedDict()

        self._vquery_time = time_func()+2.5
        self._version_check_started = False
        self._version_check_done = False

        self._last_adc = 0
        self._last_draw = 0.0

        self._last_switch = 0.0
        self.current_color = (255,255,255)

        self.additional_lag = 0.0 # add more lag here to double-check measurement

        pygame.display.init()
        pygame.font.init()
        self.screen = pygame.display.set_mode( (320,240) )
        #self.font = pygame.font.Font(None, 100)
        #self.font = pygame.font.match_font('Arial')
        self.font = pygame.font.SysFont("Arial",18)

        self.clear_data()
        self.time_model = None

    def set_led(self,value):
        char = chr(value)
        self.ser.write('L'+char)

    def clear_data(self):
        print 'cleared data'
        self.switches = []
        self.times = []
        self.adcs = []

    def save_to_disk(self):
        for table in ['switches', 'times', 'adcs']:
            fname = table+'.csv'
            data = getattr(self,table)
            with open(fname,mode='w') as fd:
                for row in data:
                    fd.write( ','.join( map(repr,row) ) + '\n' )

    def run(self):
        buf = ''
        black = (0,0,0)
        white = (255,255,255)
        schedule_switch = False

        while 1:
            buf += self.ser.read()
            #print '                               %d: %r'%(len(buf),buf)
            while len(buf) >= 9:
                buf = self._h(buf)

            now = time_func()
            if (now - self.last_time) > QUERY_DT:
                # request sample

                self._queries[ self._qi ] = now

                #print 'timestamp query', self._qi
                self.ser.write( 'P'+chr(self._qi) )

                self._qi = (self._qi + 1) % 256
                self.last_time = now
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return
                elif event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_c:
                        self.clear_data()
                        print 'cleared'
                    elif event.key == pygame.K_s:
                        self.save_to_disk()
                        print 'saved'

            if (now - self._last_switch) > SWITCH_DT:
                schedule_switch = True
                save_switch = True
                self._last_switch = now
                if self.current_color[0]==0:
                    next_color = white
                else:
                    next_color = black
            else:
                save_switch = False

            if schedule_switch and (now-self._last_switch) >= self.additional_lag:
                switch = True
                self.current_color = next_color
                schedule_switch = False
            else:
                switch = False

            # throttle drawing
            if (now - self._last_draw) >= DRAW_DT or switch or save_switch:

                self.screen.fill(black)
                self.screen.fill( self.current_color,
                                  pygame.Rect(25,25,200,200))

                adc = self.get_last_adc()
                surf = self.font.render("luminance: %d" % adc, True, white)
                self.screen.blit( surf, (5,5) )
                if save_switch:

                    # Record the time immediately prior to the call to
                    # flip(). While we could record it afterward, that
                    # doesn't measure total system latency() from when
                    # done drawing to the display on the screen.

                    flip_time = time_func()
                    self.set_led(next_color[0])
                    self.switches.append( (flip_time, next_color[0]/255 ) )
                pygame.display.flip()

                self._last_draw = now

            # version check
            if not self._version_check_done:
                if not self._version_check_started:
                    if now >= self._vquery_time:
                        self.ser.write( 'V?' )
                        self._version_check_started = True
                        print 'made version request'

                if (now - self._vquery_time) > 2.5:
                    warnings.warn('no response to version query')

    def get_last_adc(self):
        return self._last_adc

    def _handle_version(self, value, epoch, count):
        assert value==2
        self._vquery_time = time_func()
        self._version_check_done = True
        print 'version OK'

    def _handle_returned_timestamp(self, qi, epoch, counter):
        now = time_func()

        while len(self._queries) > 50:
            old_qi = self._queries.popitem(last=False)
            print 'old_qi',old_qi
            print 'WARNING: never got return for query %d'%old_qi

        try:
            send_timestamp = self._queries.pop( qi )
        except KeyError:
            print 'WARNING: could not find original data for query %d'%qi
            return

        max_error = now-send_timestamp
        if max_error > 0.015: # 15 msec cutoff
            print 'WARNING: clock sample took %.1f msec. Ignoring value.'%( max_error*1e3 )
            return

        ino_time_estimate = (now+send_timestamp)*0.5
        ino_stamp = epoch*2**16 + counter

        self.times.append( (ino_time_estimate, ino_stamp) )
        if len(self.times) > 3:
            # require 3 samples to start attempting to fit model
            tdata = np.array(self.times[-100:])
            try:
                self.time_model = get_time_model(tdata[:,1], tdata[:,0])
            except TimeFitError, err:
                print 'WARNING: error fitting time_model: %s'%err

    def _h(self,buf):
        result = buf
        if len(buf) >= 9:
            valid = False
            #print repr(buf)

            if buf[0] in ('H','P','V','L'):
                packet_type = buf[0]
                bytes = [ord(char) for char in buf[1:9]]
                value = bytes[0]
                e0,e1,e2,e3 = bytes[1:5]
                t0,t1 = bytes[5:7]
                expected_chksum = bytes[7]
                actual_chksum = sum( bytes[:7] ) % 256
                #print bytes

                if actual_chksum == expected_chksum:
                    valid = True
                # if packet_type != 'H':
                #     print '%s: %d,%d,%d'%(packet_type, value, uint32(e0,e1,e2,e3), uint16(t0,t1) )
                epoch = uint32(e0,e1,e2,e3)
                count = uint16(t0,t1)

                if packet_type == 'H':
                    self._last_adc = value
                    C_arduino = epoch*2**16 + count
                    self.adcs.append( (C_arduino,value) )

                if packet_type == 'P':
                    self._handle_returned_timestamp(value, epoch, count )
                elif packet_type == 'V':
                    self._handle_version(value, epoch, count )
                elif packet_type == 'L':
                    pass

            if valid:
                #print 'valid'
                result = buf[9:]

            if not valid:
                print 'not valid'
                result = buf[1:] # ignore this potential start and do a frame-shift

        return result

if __name__=='__main__':
    app=MyApp()
    app.run()
